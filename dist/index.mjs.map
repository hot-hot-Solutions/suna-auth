{"version":3,"sources":["../src/functions/auth.ts","../src/functions/jwt.ts","../src/functions/responces.ts","../src/routes/callback/[id]/route.ts","../src/routes/signIn/route.ts","../src/routes/signOut/route.ts","../src/routes/message/route.ts","../src/routes/error/route.ts","../src/routes/route.ts","../src/index.ts"],"sourcesContent":["import \"server-only\";\r\n\r\nimport { cookies } from \"next/headers\";\r\nimport { Session } from \"../types\";\r\nimport { Auth } from \"../index\";\r\nimport { decodeToken } from \"./jwt\";\r\n\r\nexport async function sessionsInternal(): Promise<false | Session> {\r\n  const cookie = cookies();\r\n  const sessionTokenString = cookie.get(\"SessionToken\")?.value;\r\n\r\n  if (!sessionTokenString) return false;\r\n\r\n  try {\r\n    const decodedPayload = await decodeToken(sessionTokenString);\r\n    if (\r\n      !decodedPayload ||\r\n      !decodedPayload.payload ||\r\n      !decodedPayload.payload.provider\r\n    )\r\n      return false;\r\n\r\n    const currentProvider =\r\n      Auth.config[decodedPayload.payload.provider as keyof typeof Auth.config];\r\n\r\n    /*let cacheAccount: IAccounts | undefined = undefined\r\n    if (currentProvider.cache) {\r\n      const cachedAccountString = await currentProvider.cache.getValue(Session)\r\n      if (cachedAccountString) cacheAccount = JSON.parse(cachedAccountString)\r\n    }*/\r\n\r\n    const userSession =\r\n      await currentProvider.provider.handleAuthCheck(sessionTokenString);\r\n\r\n    if (!userSession) return false;\r\n    return await Auth.callbacks.handleAuthCheck(userSession);\r\n  } catch (e) {\r\n    console.log(\"Error while fetching session token\", e);\r\n    return false;\r\n  }\r\n}\r\n","import {\r\n  importPKCS8,\r\n  jwtVerify,\r\n  type JWTVerifyResult,\r\n  KeyLike,\r\n  SignJWT,\r\n} from \"jose\";\r\nimport { nanoid } from \"nanoid\";\r\nimport { Buffer } from \"buffer\";\r\nimport { Auth } from \"../index\";\r\n\r\nexport interface CreatTokenPayload {\r\n  provider: string;\r\n  email: string;\r\n  sub: string;\r\n\r\n  [key: string]: string;\r\n}\r\n\r\nlet privateKey: KeyLike | Uint8Array;\r\nexport const getPrivateKey = async (): Promise<KeyLike | Uint8Array> => {\r\n  return (privateKey =\r\n    privateKey ||\r\n    (await importPKCS8(\r\n      Buffer.from(Auth.secret.secret, \"base64\").toString(\"utf-8\"),\r\n      Auth.secret.algorithm,\r\n    )));\r\n};\r\n\r\nexport const createToken = async (\r\n  data: CreatTokenPayload,\r\n  expiration: Date,\r\n): Promise<string> => {\r\n  const privateKey = await getPrivateKey();\r\n  return await new SignJWT({\r\n    ...data,\r\n  })\r\n    .setProtectedHeader({ alg: Auth.secret.algorithm })\r\n    .setJti(nanoid())\r\n    .setIssuedAt()\r\n    .setExpirationTime(expiration)\r\n    .sign(privateKey);\r\n};\r\n\r\nexport const decodeToken = async <T = CreatTokenPayload>(\r\n  sessionTokenString: string,\r\n): Promise<JWTVerifyResult<T> | false> => {\r\n  try {\r\n    const privateKey = await getPrivateKey();\r\n    return await jwtVerify<T>(sessionTokenString, privateKey);\r\n  } catch (e) {\r\n    console.log(e);\r\n    return false;\r\n  }\r\n};\r\n","/*\r\n * For all Api routes responses use custom handler for data normalization\r\n *\r\n * Consistency is key - Random Person\r\n * */\r\n\r\n/**\r\n * Sends an error response with the given status and message.\r\n *\r\n * @param {number} status - The HTTP status code of the error response.\r\n * @param {string} message - The error message to be included in the response.\r\n * @returns {object} - The error response object.\r\n */\r\nexport const sendError = (status: number, message: string): Response => {\r\n  return Response.json(\r\n    {\r\n      success: false,\r\n      status: status,\r\n      message: message,\r\n    },\r\n    {\r\n      status: status,\r\n      statusText: message,\r\n    },\r\n  );\r\n};\r\n\r\n/**\r\n * Creates a JSON response object with optional status code.\r\n *\r\n * @param {any} data - The data to be included in the response.\r\n * @param {number} [code] - The optional status code for the response.\r\n * @returns {object} - The JSON response object.\r\n */\r\nexport const sendJson = (data: any, code?: number): Response => {\r\n  return Response.json(\r\n    {\r\n      success: true,\r\n      data: data,\r\n    },\r\n    {\r\n      status: code,\r\n    },\r\n  );\r\n};\r\n\r\n/**\r\n * Redirects to the error page with the provided status and message.\r\n *\r\n * @param {number} status - The HTTP status code of the error.\r\n * @param {string} message - The error message.\r\n */\r\nexport const sendErrorRedirect = (status: number, message: string): Response => {\r\n  return Response.redirect(\r\n    `${process.env.NEXTAUTH_URL}/api/auth/error?message=${message}&code=${status}`,\r\n    302,\r\n  );\r\n};\r\n","import { NextRequest } from \"next/server\";\r\nimport { Auth } from \"../../../index\";\r\nimport { SingleConfig } from \"../../../types\";\r\nimport { sendErrorRedirect } from \"../../../functions/responces\";\r\n\r\nexport async function GET(\r\n  request: NextRequest,\r\n  {\r\n    params,\r\n  }: {\r\n    params: {\r\n      [key: string]: string[];\r\n    };\r\n  },\r\n) {\r\n  const key = Object.keys(params)[0];\r\n  if (!params[key].at(-1))\r\n    return sendErrorRedirect(500, \"this provider is not implemented\");\r\n  const authProvider: SingleConfig =\r\n    Auth.config[params[key].at(-1) as keyof typeof Auth.config];\r\n\r\n  return authProvider.provider.handleCallback(request);\r\n}\r\n","import { NextRequest } from \"next/server\";\nimport { sendError } from \"../../functions/responces\";\nimport { Auth } from \"../../index\";\n\nexport async function GET(request: NextRequest) {\n  const searchParams = request.nextUrl.searchParams;\n  const provider = searchParams.get(\"provider\") as\n    | keyof typeof Auth.config\n    | null;\n  const referer =\n    request.headers.get(\"redirect_url\") ||\n    request.headers.get(\"referer\") ||\n    \"/\";\n\n  if (!provider) return sendError(400, \"please provide a ?provider\");\n\n  const providerData = Auth.config[provider];\n\n  if (!providerData)\n    return sendError(400, `Provider ${provider} is not supported.`);\n\n  return providerData.provider.handleSignIn(request, referer);\n}\n","import { cookies } from \"next/headers\";\r\n\r\nexport async function GET() {\r\n  const cookieHandler = cookies();\r\n  cookieHandler.delete(\"SessionToken\");\r\n\r\n  return new Response();\r\n}\r\n","export async function GET(request: { nextUrl: { searchParams: any } }) {\n  const searchParams = request.nextUrl.searchParams;\n  const message = searchParams.get(\"message\");\n  const code = searchParams.get(\"code\");\n\n  return new Response(\n    `<!DOCTYPE html>\n<html>\n<head>\n    <style>\n        body {\n            background-color: black;\n            color: white;\n        }\n    </style>\n</head>\n<body>\n    <h1>Message: </h1>\n    <p id=\"message\">${message}</p>\n\n    <h1>Code: </h1>\n    <p id=\"code\">${code}</p>\n</body>\n</html>`,\n    {\n      headers: { \"Content-Type\": \"text/html\" },\n    },\n  );\n}\n","export async function GET(request: { nextUrl: { searchParams: any } }) {\n  const searchParams = request.nextUrl.searchParams;\n  const message = searchParams.get(\"message\");\n  const code = searchParams.get(\"code\");\n\n  return new Response(\n    `<!DOCTYPE html>\n<html>\n<head>\n    <style>\n        body {\n            background-color: black;\n            color: white;\n        }\n    </style>\n</head>\n<body>\n    <h1>Message: </h1>\n    <p id=\"message\">${message}</p>\n\n    <h1>Code: </h1>\n    <p id=\"code\">${code}</p>\n</body>\n</html>`,\n    {\n      headers: { \"Content-Type\": \"text/html\" },\n    },\n  );\n}\n","import { GET as callback } from \"./callback/[id]/route\";\nimport { GET as signIn } from \"./signIn/route\";\nimport { GET as signOut } from \"./signOut/route\";\nimport { GET as message } from \"./message/route\";\nimport { GET as error } from \"./error/route\";\nimport { createEdgeRouter } from \"next-connect\";\nimport { NextRequest } from \"next/server\";\n\ninterface RequestContext {\n  params: {\n    [key: string]: string[];\n  };\n}\n\nconst handler = createEdgeRouter<NextRequest, RequestContext>();\n\n// Define your routes\nhandler.get(\"/api/auth/callback/:id\", callback);\nhandler.get(\"/api/auth/signOut\", signOut);\nhandler.get(\"/api/auth/signIn\", signIn);\nhandler.get(\"/api/auth/message\", message);\nhandler.get(\"/api/auth/error\", error);\n\nexport async function GET(\n  request: NextRequest,\n  ctx: RequestContext,\n): Promise<void | Response> {\n  return handler.run(request, ctx) as Promise<void | Response>;\n}\n","import { sessionsInternal } from \"./functions/auth\";\nimport {\n  AccountType,\n  Config,\n  Secret,\n  Session,\n  SessionType,\n  UserType,\n} from \"./types\";\nimport { GET } from \"./routes/route\";\nimport { sendError, sendErrorRedirect, sendJson } from \"./functions/responces\";\nimport { createToken, decodeToken } from \"./functions/jwt\";\n\nexport class Auth {\n  public static config: Config;\n  public static secret: Secret;\n  public auth;\n  public routes;\n  public static callbacks: {\n    handleAuthCheck(session: Session): Promise<Session>;\n    handleCreate(\n      account: AccountType,\n      user: UserType,\n      session: SessionType,\n    ): Promise<any>;\n  };\n\n  constructor(\n    config: Config,\n    secret: any,\n    callbacks: typeof Auth.callbacks = {\n      handleAuthCheck: async (session: Session) => session,\n      handleCreate: async (\n        account: AccountType,\n        user: UserType,\n        session: SessionType,\n      ) => undefined,\n    },\n  ) {\n    Auth.config = config;\n    Auth.secret = secret;\n    Auth.callbacks = callbacks;\n\n    this.routes = { GET: GET };\n    this.auth = sessionsInternal;\n  }\n}\n\nexport { sendError, sendJson, sendErrorRedirect, decodeToken, createToken };\n"],"mappings":"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","names":["privateKey","GET","cookies","GET","cookies","GET","GET","GET","GET"]}